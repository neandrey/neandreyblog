<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="https://neandreyblog.herokuapp.com/theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="https://neandreyblog.herokuapp.com/theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="https://neandreyblog.herokuapp.com/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="ne_andrey">
  <meta name="description" content="Posts and writings by ne_andrey">

  <link href="https://neandreyblog.herokuapp.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="ne_andrey Atom" />

<meta name="keywords" content="">

  <title>
    ne_andrey
&ndash; Linux System Mining with Python  </title>

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="https://neandreyblog.herokuapp.com">
        <img src="https://neandreyblog.herokuapp.com/theme/images/logo.png" alt="logo">
      </a>
      <h2><a href="https://neandreyblog.herokuapp.com">ne_andrey</a></h2>
      <p>anykey developer</p>
      <ul>
        <li><a href="https://github.com/neandrey" target="_blank">GitHub</a></li>
        <li><a href="https://twitter.com/ne_andrey?lang=ru" target="_blank">Twitter</a></li>
      </ul>
    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href="https://neandreyblog.herokuapp.com">Index</a> &brvbar; <a href="https://neandreyblog.herokuapp.com/archives.html">Archives</a>
      &brvbar; <a href="https://neandreyblog.herokuapp.com/feeds/all.atom.xml">Atom</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h1><a href="https://neandreyblog.herokuapp.com/linux-system-mining-with-python.html">Linux System Mining with Python</a></h1>
  </div>
  <div class="article_text">
    <p>В этой статье мы исследуем инструменты языка 
python для получения различной информации о 
работе системы Linux. Давайте начнем.</p>
<h4>Какой интерпритатор python?</h4>
<p>Когда я говорю о python я ссылаюсь на CPython2 (2.7 если быть точным). Я должен упамянуть об
этом явно потому что тот же код не будет работает на python3 (3.3) и будет предоставлен
альтернативный код, объясняющий различия. Просто чтобы убедиться, что у вас установлен CPython
введите <code>python</code> или <code>python3</code> на терминале и вы должны увидеть приглашение python на своём 
дисплее.</p>
<div class="highlight"><pre><span></span>$ python
Python <span class="m">3</span>.6.4 <span class="o">(</span>default, Jan  <span class="m">5</span> <span class="m">2018</span>, <span class="m">02</span>:35:40<span class="o">)</span> 
<span class="o">[</span>GCC <span class="m">7</span>.2.1 <span class="m">20171224</span><span class="o">]</span> on linux
Type <span class="s2">&quot;help&quot;</span>, <span class="s2">&quot;copyright&quot;</span>, <span class="s2">&quot;credits&quot;</span> or <span class="s2">&quot;license&quot;</span> <span class="k">for</span> more information.
<span class="p">&amp;</span>gt<span class="p">;&amp;</span>gt<span class="p">;&amp;</span>gt<span class="p">;</span>
</pre></div>


<h4>Примечание.</h4>
<p>Пожалуйста заметьте, что все программы имеют первую строку <code>#!/usr/bin/env python</code> которая 
означает,что вы хотите использовать интерпритатор python для выполнения данного скрипта.
Если вы хотите сделать свой скрипт исполняемым используйте команду <code>chmod + x your-script.py</code>. 
Для выполнения вашего скрипта используйте команду <code>./your-script.py</code></p>
<h4>Исследование модулей системы.</h4>
<p>модуль <code>platform</code> в стандартной библиотеки имеет ряд функций которые позволяют нам возвращать
информацию о системных переменных. Давайте запустим наш интерпритатор <code>python</code> и выполним
некоторые из них, начнем с функции <code>platform.uname()</code></p>
<div class="highlight"><pre><span></span>    <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">platform</span>
    <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">platform</span><span class="o">.</span><span class="n">uname</span><span class="p">()</span>
        <span class="p">(</span><span class="s1">&#39;Linux&#39;</span><span class="p">,</span> <span class="s1">&#39;fedora.echorand&#39;</span><span class="p">,</span> <span class="s1">&#39;3.7.4-204.fc18.x86_64&#39;</span><span class="p">,</span> <span class="s1">&#39;#1 SMP Wed Jan 23 16:44:29 UTC 2013&#39;</span><span class="p">,</span> <span class="s1">&#39;x86_64&#39;</span><span class="p">)</span>
</pre></div>


<p>Если вы в курсе о команде <code>uname</code> в системе Linux вы сразу поймете, что это функция является
интерфейсом данной команды. На python2 эта функция возвращает кортеж 
состоящий из: названия системы (названия Ядра), имени хоста, версии, релиза, разрядность машины и
информацию о процессоре. Вы можете получить доступ к отдельным атрибутам вот так:</p>
<div class="highlight"><pre><span></span>    &amp;gt;&amp;gt;&amp;gt; platform.uname()[0]
        &#39;Linux&#39;
</pre></div>


<p>На Python 3, функция вернет именованный кортеж:</p>
<div class="highlight"><pre><span></span>    &amp;gt;&amp;gt;&amp;gt; platform.uname()

    uname_result(system=&#39;Linux&#39;, node=&#39;fedora.echorand&#39;,
    release=&#39;3.7.4-204.fc18.x86_64&#39;, version=&#39;#1 SMP Wed Jan 23 16:44:29
    UTC 2013&#39;, machine=&#39;x86_64&#39;, processor=&#39;x86_64&#39;)
</pre></div>


<p>Поскольку возвращаемый результат - именованный кортеж, доступ к отдельным атребутам 
можно получить по имени, вместо того чтобы запоминать индекс.</p>
<div class="highlight"><pre><span></span>    &amp;gt;&amp;gt;&amp;gt; platform.uname().system
        &#39;Linux&#39;
</pre></div>


<p>модуль <code>platform</code> так же имеет непосредственный доступ к вышеперечисленным атрибутам</p>
<div class="highlight"><pre><span></span>    &amp;gt;&amp;gt;&amp;gt; platform.system()
        &#39;Linux&#39;

    &amp;gt;&amp;gt;&amp;gt; platform.release()
        &#39;3.7.4-204.fc18.x86_64&#39;
</pre></div>


<p>Функция <code>linux_distribution()</code> возвращает детали Linux дистрибутиве установленном на вашей машине.
Для примера взят дистрибутив Fedora 18 после вызова команда вернет:</p>
<div class="highlight"><pre><span></span>    &amp;gt;&amp;gt;&amp;gt; platform.linux_distribution()
        (&#39;Fedora&#39;, &#39;18&#39;, &#39;Spherical Cow&#39;)
</pre></div>


<p>Результат возвращается в кортеже состоящем из имени дистрибутива, версии, и названием сборки.
Дистрибутивы поддерживающие вашу версию Python могут быть получены вызовом атрибута </p>
<div class="highlight"><pre><span></span>    &amp;gt;&amp;gt;&amp;gt; platform._supported_dists
    (&#39;SuSE&#39;, &#39;debian&#39;, &#39;fedora&#39;, &#39;redhat&#39;, &#39;centos&#39;, &#39;mandrake&#39;,
    &#39;mandriva&#39;, &#39;rocks&#39;, &#39;slackware&#39;, &#39;yellowdog&#39;, &#39;gentoo&#39;,
    &#39;UnitedLinux&#39;, &#39;turbolinux&#39;)
</pre></div>


<p>Если вашего дистрибутива Linux нет в списке, тогда вы не увидите никакой информации из приведенного выше
вызова функции.</p>
<p>Последней функция из модуля <code>platform</code> мы рассмотрим <code>architecture()</code>. Когда мы вызываем эту функцию без аргументов,
эта функция вернет кортеж с разрядностью архитектуры и типом исполняемого формата Python.</p>
<div class="highlight"><pre><span></span>    &amp;gt;&amp;gt;&amp;gt; platform.architecture()
        (&#39;64bit&#39;, &#39;ELF&#39;)
</pre></div>


<p>На 32-разрядных системах Linux вы увидите:</p>
<div class="highlight"><pre><span></span>    &amp;gt;&amp;gt;&amp;gt; platform.architecture()
        (&#39;32bit&#39;, &#39;ELF&#39;)
</pre></div>


<p>Вы получите тот же результат если укажите любой другой исполняемый файл:</p>
<div class="highlight"><pre><span></span>    &amp;gt;&amp;gt;&amp;gt; platform.architecture(executable=&#39;/usr/bin/ls&#39;)
        (&#39;64bit&#39;, &#39;ELF&#39;)
</pre></div>


<p>Вам предлагается изучить другие функции модуля <code>platform</code>, которые среди прочего позволяют найти текущуюю версию
Python которую вы используете. Если вы заинтересованы узнать как этот модуль извлекает информацию. 
Вам стоит рассмотреть файл lib\platform.py в каталоге с исходным кодом языка Python.</p>
<p>Модули <code>os</code> и <code>sys</code> так же предоставляют интерес для получения определенных системных атрибутов
таких как порядок следования байт. Далее мы выходим за рамки модулей стандартной библиотеки Python,
чтобы исследовать некоторые общие подходы для доступа к информации о системе Linux, доступной
через <code>proc</code> и <code>sysfs</code>. Следует отметить, что информация доступная через <code>proc</code> и <code>sysfs</code> может 
различаться на разных архитектурах и следовательно вы должны иметь это ввиду при написании сценариев.</p>
<h4>Информация о процессоре</h4>
<p>Файл <code>/proc/cpuinfo</code> содержат информацию о процессоре на вашей системы. 
Для примера приведена версия команды cat /proc/cpuinfo на языке python.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#! /usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot; print out the /proc/cpuinfo</span>
<span class="sd">file</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/proc/cpuinfo&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>когда вы выполняете эту программу на <code>python2</code> или <code>python3</code> вы должоны увидеть всё содержимое файла 
на своем монеторе.
В программе выше метод <a href="https://www.tutorialspoint.com/python/string_rstrip.htm">rstrip()</a> 
удаляет конечные символы новой строки. </p>
<p>Следуюший код показывает использования строкового мтеода 
<a href="https://www.tutorialspoint.com/python/string_startswith.htm">startswith()</a> и
возвращает на дисплей модель вашего процессора.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#! /usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot; Print the model of your</span>
<span class="sd">processing units</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/proc/cpuinfo&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Ignore the blank line separating the information between</span>
        <span class="c1"># details about two processing units</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;model name&#39;</span><span class="p">):</span>
                <span class="n">model_name</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">print</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>когда вы запустите эту программу вы должны увдеть назвние каждого процессорного модуля.</p>
<p>Для примера вот что получилось у меня:</p>
<div class="highlight"><pre><span></span>Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz
Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz
Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz
Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz
</pre></div>


<p>Мы до сих пор видели несколько способов как определить архитектуру компьютерной системы в которой мы находимся.
Чтобы быть технически корректным оба этих подхода фактически сообщает об архитектуре
ядра на котором работает ваша система. Если ваш компьютер является 64-разрядным а работает на 32-разрядном ядре то эти 
методы сообщат вам о 32-разарядной архитектуре. Чтобы найти истенную архитектуру компьютера вам необходимо найти 
флаг <code>lm</code> в списке флагов в файле <code>/proc/cpuinfo</code>. Флаг <code>lm</code> обозначает длительный режим и присутствует только на 
компьютерах с 64-разрядной архитектурой. 
Следующий листинг показывает как вы можете это сделать.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#! /usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot; </span>
<span class="sd">Find the real bit architecture</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/proc/cpuinfo&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Ignore the blank line separating the information between</span>
        <span class="c1"># details about two processing units</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;flags&#39;</span><span class="p">)</span> \
                    <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Features&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;lm&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
                    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;64-bit&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;32-bit&#39;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Как мы уже видели чтение файла <code>/proc/cpuinfo</code> возможно с использованием простых текстовых методов.
Для того чтобы сделать чтение более удобным по отношению к другим программам использующем данные. 
Лучший способ создать структуру данных такую как словарь.
Идея простая если вы просмотрите содержимое  файла <code>/proc/cpuinfo</code> то можете заметить каждая обрабатываемая 
единица данных имеет пару ключ значение. (ранее мы выводили имя процессора которое является ключем)
Информация о любых процессорных устройствах разделены друг от друга пустой строкой.
Проще построить словарь для которого каждое процессорное устройство используется как ключь.
Для каждого такого ключа значением является вся информация о соответствующем процессоре, предоставленная
в файле <code>/proc/cpuinfo</code>.
Следующий листинг показывает как можно это сделать:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env/ python</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">/proc/cpuinfo as a Python dict</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">pprint</span>

<span class="k">def</span> <span class="nf">cpuinfo</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39; Return the information in /proc/cpuinfo</span>
<span class="sd">    as a dictionary in the following format:</span>
<span class="sd">    cpu_info[&#39;proc0&#39;]={...}</span>
<span class="sd">    cpu_info[&#39;proc1&#39;]={...}</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">cpuinfo</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">()</span>
    <span class="n">procinfo</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">()</span>

    <span class="n">nprocs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/proc/cpuinfo&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="c1"># end of one processor</span>
                <span class="n">cpuinfo</span><span class="p">[</span><span class="s1">&#39;proc</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">nprocs</span><span class="p">]</span> <span class="o">=</span> <span class="n">procinfo</span>
                <span class="n">nprocs</span><span class="o">=</span><span class="n">nprocs</span><span class="o">+</span><span class="mi">1</span>
                <span class="c1"># Reset</span>
                <span class="n">procinfo</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">procinfo</span><span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">procinfo</span><span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

<span class="k">return</span> <span class="n">cpuinfo</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">cpuinfo</span> <span class="o">=</span> <span class="n">cpuinfo</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">processor</span> <span class="ow">in</span> <span class="n">cpuinfo</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">cpuinfo</span><span class="p">[</span><span class="n">processor</span><span class="p">][</span><span class="s1">&#39;model name&#39;</span><span class="p">])</span>
</pre></div>
</td></tr></table>

<p>Этот код использует  <a href="https://pymotw.com/2/collections/ordereddict.html">OrderedDict</a>
вместо обычного словоря так что ключи и значения находятся в том порядке в котором они находятся
в файле. Следовательно данные для первого процессора за ним данные для второго и так далее (по порядку).
Если вы вызываете эту функцию то получите словарь в качестве возвращаемого значения.
Каждый ключ словоря является отдельным процессорным модулем.
Затем ва можете использовать цикл for для выбора нужной вам информации (как продемонстрировано в
блоке if <strong>name</strong>=='<strong>main</strong>').
Когда вы запустите программу вы еще раз увидите название каждого модуля процессора (как указано в вызове 
функции print(cpuinfo[processor]['model name']).</p>
<div class="highlight"><pre><span></span>Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz
Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz
Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz
Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz
</pre></div>


<h4>Информация о памяти.</h4>
<p>Аналогично /proc/cpuinfo файл /proc/meminfo содержит информацию о памяти установленной на вашем компьютере.
В следующей программе создается словарь с данными из этого файла.
Как вы видели ранее вы можете получить любую информацию используя её как ключ словоря.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="k">def</span> <span class="nf">meminfo</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39; Return the information in /proc/meminfo</span>
<span class="sd">    as a dictionary &#39;&#39;&#39;</span>
    <span class="n">meminfo</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/proc/meminfo&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">meminfo</span><span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">meminfo</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1">#print(meminfo()) #выводит на печать все данные из файла /proc/meminfo</span>

    <span class="n">meminfo</span> <span class="o">=</span> <span class="n">meminfo</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Total memory: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">meminfo</span><span class="p">[</span><span class="s1">&#39;MemTotal&#39;</span><span class="p">]))</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Free memory: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">meminfo</span><span class="p">[</span><span class="s1">&#39;MemFree&#39;</span><span class="p">]))</span>
</pre></div>
</td></tr></table>

<p>Когда вы выполните программу вы должны увидеть что-то похожее на это.</p>
<div class="highlight"><pre><span></span>Total memory: 7897012 kB
Free memory: 249508 kB
</pre></div>


<h4>Сетевавя статистика.</h4>
<p>Дальше мы исследуем сетевые устройства находящиеся на вашей компьютерной системе.
Мы будем извлекать название сетевого интерфейса и число байт полученных и переданных с момента 
последней перезагрузки системы.
Данная информация находится в файле /proc/net/dev. Если вы исследуете содержимое данного файла,
то заметите что первые две строчки содержат информационный заголовок - т.е. первая колонка этого файла 
имя сетевого интерфейса, а вторая и третья колонки число переданных и принятых байт(). 
Наш интерес здесь составляет выделение всех данных переданных и принятых от различных сетевых интерфейсов.
Следующий листинг показывает как мы можем извлечь информацию из файла /proc/net/dev.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="k">def</span> <span class="nf">netdevs</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39; RX and TX bytes for each of the network devices &#39;&#39;&#39;</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/proc/net/dev&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">net_dump</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

    <span class="n">device_data</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,[</span><span class="s1">&#39;rx&#39;</span><span class="p">,</span><span class="s1">&#39;tx&#39;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">net_dump</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;lo&#39;</span><span class="p">:</span>
            <span class="n">device_data</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="n">data</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">1024.0</span><span class="o">*</span><span class="mf">1024.0</span><span class="p">),</span>
                                                <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">8</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">1024.0</span><span class="o">*</span><span class="mf">1024.0</span><span class="p">))</span>

<span class="k">return</span> <span class="n">device_data</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="n">netdevs</span> <span class="o">=</span> <span class="n">netdevs</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="n">netdevs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}: {1} MiB {2} MiB&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">netdevs</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span><span class="o">.</span><span class="n">rx</span><span class="p">,</span> <span class="n">netdevs</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span><span class="o">.</span><span class="n">tx</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Когда вы запустите эту программу вы увидите название интерфейса и общее число переданных и полученных байт с
момента последней перезагрузки системы.</p>
<div class="highlight"><pre><span></span><span class="n">em1</span><span class="o">:</span> <span class="mf">0.0</span> <span class="n">MiB</span> <span class="mf">0.0</span> <span class="n">MiB</span>
<span class="n">wlan0</span><span class="o">:</span> <span class="mf">2651.40951061</span> <span class="n">MiB</span> <span class="mf">183.173976898</span> <span class="n">MiB</span>
</pre></div>


<p>Возможно вы могли бы связать данную информацию с базой данных для написание своей собственной программы за
мониторингом сетевых данных.</p>
<h4>Процессы.</h4>
<p>/proc содержит калоги для каждого работающего процесса.
Имя директории такое же как и ID запущенного процесса.
Следовательно, если вы сканируете /proc по всем каталогам у которых в название есть цифры, у вас будет список всех
запущенных процессов.
Функция process_list() в следующем листинге возвращает список с ID работающих процессов.
Длинна этого списка будет зависеть от количества работающих процессов на вашей системе как показано в
листинге ниже.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">List of all process IDs currently active</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">process_list</span><span class="p">():</span>

    <span class="n">pids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">subdir</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;/proc&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">subdir</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">pids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subdir</span><span class="p">)</span>

<span class="k">return</span> <span class="n">pids</span>


<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="n">pids</span> <span class="o">=</span> <span class="n">process_list</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Total number of running processes:: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pids</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Вышепреведенная программа при выполнение покажет результат аналогичный этому:</p>
<div class="highlight"><pre><span></span>Total number of running processes:: 229
</pre></div>


<p>Каждый из каталогов в директории \ содержит различную информацию о вызываемых командах,
используемызх библиотеках и прочем:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Python interface to the /proc file system.</span>
<span class="sd">Although this can be used as a replacement for cat /proc/... on the command line,</span>
<span class="sd">its really aimed to be an interface to /proc for other Python programs.</span>

<span class="sd">As long as the object you are looking for exists in /proc</span>
<span class="sd">and is readable (you have permission and if you are reading a file,</span>
<span class="sd">its contents are alphanumeric, this program will find it). If its a</span>
<span class="sd">directory, it will return a list of all the files in that directory</span>
<span class="sd">(and its sub-dirs) which you can then read using the same function.</span>


<span class="sd">Example usage:</span>

<span class="sd">Read /proc/cpuinfo:</span>

<span class="sd">$ ./readproc.py proc.cpuinfo</span>

<span class="sd">Read /proc/meminfo:</span>

<span class="sd">$ ./readproc.py proc.meminfo</span>

<span class="sd">Read /proc/cmdline:</span>

<span class="sd">$ ./readproc.py proc.cmdline</span>

<span class="sd">Read /proc/1/cmdline:</span>

<span class="sd">$ ./readproc.py proc.1.cmdline</span>

<span class="sd">Read /proc/net/dev:</span>

<span class="sd">$ ./readproc.py proc.net.dev</span>

<span class="sd">Comments/Suggestions:</span>

<span class="sd">Amit Saha &amp;lt;@echorand&amp;gt;</span>
<span class="sd">&amp;lt;http://echorand.me&amp;gt;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">def</span> <span class="nf">toitem</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="sd">&quot;&quot;&quot; Convert /foo/bar to foo.bar &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span>

<span class="k">def</span> <span class="nf">todir</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert foo.bar to /foo/bar&quot;&quot;&quot;</span>
    <span class="c1"># TODO: breaks if there is a directory whose name is foo.bar (for</span>
    <span class="c1"># eg. conf.d/), but we don&#39;t have to worry as long as we are using</span>
    <span class="c1"># this for reading /proc</span>
    <span class="k">return</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">readproc</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resolves proc.foo.bar items to /proc/foo/bar and returns the</span>
<span class="sd">    appropriate data.</span>
<span class="sd">    1. If its a file, simply return the lines in this file as a list</span>
<span class="sd">    2. If its a directory, return the files in this directory in the</span>
<span class="sd">    proc.foo.bar style as a list, so that this function can then be</span>
<span class="sd">    called to retrieve the contents</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">todir</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Non-existent object&#39;</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
        <span class="c1"># its a little tricky here. We don&#39;t want to read huge binary</span>
        <span class="c1"># files and return the contents. We will probably not need it</span>
        <span class="c1"># in the usual case.</span>
        <span class="c1"># utilities like &#39;file&#39; on Linux and the Python interface to</span>
        <span class="c1"># libmagic are useless when it comes to files in /proc for</span>
        <span class="c1"># detecting the mime type, since the these are not on-disk</span>
        <span class="c1"># files.</span>
        <span class="c1"># Searching, i find this solution which seems to be a</span>
        <span class="c1"># reasonable assumption. If we find a &#39;\0&#39; in the first 1024</span>
        <span class="c1"># bytes of a file, we declare it as binary and return an empty string</span>
        <span class="c1"># however, some of the files in /proc which contain text may</span>
        <span class="c1"># also contain the null byte as a constituent character.</span>
        <span class="c1"># Hence, I use a RE expression that matches against any</span>
        <span class="c1"># combination of alphanumeric characters</span>
        <span class="c1"># If any of these conditions suffice, we read the file&#39;s contents</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;\w*&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">chunk</span> <span class="ow">or</span> <span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
                    <span class="k">return</span> <span class="n">data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s1">&#39;{0} is binary&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Error reading object&#39;</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dir_path</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">toitem</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="nb">file</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">data</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">readproc</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">readproc</span><span class="p">(</span><span class="s1">&#39;proc&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h4>Блочные устройства.</h4>
<p>В следующем программном листинге все блочные устройства читаются из виртуальной файловой системы
sysfs. Блочные устройства на вашем компьютере могут быть найдены в директории /sys/block.
Так же у вас может быть такие директории как /sys/block/sda, /sys/block/sdb.
Чтобы найти все блочные устройства надо выполнить сканирование \ с помощью регулярного выражения 
в котором мы пишем интересующиее нас устройства.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Read block device data from sysfs</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Add any other device pattern to read from</span>
<span class="n">dev_pattern</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sd.*&#39;</span><span class="p">,</span><span class="s1">&#39;mmcblk*&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">device</span><span class="p">):</span>
    <span class="n">nr_sectors</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">device</span><span class="o">+</span><span class="s1">&#39;/size&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">sect_size</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">device</span><span class="o">+</span><span class="s1">&#39;/queue/hw_sector_size&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># The sect_size is in bytes, so we convert it to GiB and then send it back</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">nr_sectors</span><span class="p">)</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">sect_size</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mf">1024.0</span><span class="o">*</span><span class="mf">1024.0</span><span class="o">*</span><span class="mf">1024.0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">detect_devs</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;/sys/block/*&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">dev_pattern</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">device</span><span class="p">)):</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Device:: {0}, Size:: {1} GiB&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="n">device</span><span class="p">)))</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">detect_devs</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Если ва выполните эту программу то получите на выходе что-то подобное:</p>
<div class="highlight"><pre><span></span>Device:: /sys/block/sda, Size:: 465.761741638 GiB
Device:: /sys/block/mmcblk0, Size:: 3.70703125 GiB
</pre></div>


<p>Когда явыполнял программу у меня была воткнута SD карта
и вы можете видеть что программа её обнаружила.</p>
<h4>Создание утилит командной строки.</h4>
<p>Одной из основных особенностей утилит командной строки Linux является наличие
аргументов, которые позволяют настроить поведение программы.
Модуль <code>argparse</code> позваляет вашим программам иметь такой же интерфейс как и у программ командной строки Linux.
В следующей программе показано извлечение всех пользователей зарегеастрированных 
в вашей системе и печать их на терминале.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Print all the users and their login shells</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">pwd</span>


<span class="c1"># Get the users from /etc/passwd</span>
<span class="k">def</span> <span class="nf">getusers</span><span class="p">():</span>
    <span class="n">users</span> <span class="o">=</span> <span class="n">pwd</span><span class="o">.</span><span class="n">getpwall</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">users</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}:{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">pw_name</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">pw_shell</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">getusers</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Когда вы запустите данную программу она напечатает всех пользователей в вашей системе и их оболочку для входа.</p>
<p>Теперь мы хотим чтобы пользователь программы мог выбрать хочет он видеть пользователей системы.
Мы увидем использование модуля <code>argparse</code> для реализации этой функции путем расширения предыдушего списка.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Utility to play around with users and passwords on a Linux system</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">pwd</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">read_login_defs</span><span class="p">():</span>

    <span class="n">uid_min</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">uid_max</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;/etc/login.defs&#39;</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/login.defs&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">login_data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">login_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;UID_MIN&#39;</span><span class="p">):</span>
                <span class="n">uid_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;UID_MAX&#39;</span><span class="p">):</span>
                <span class="n">uid_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">uid_min</span><span class="p">,</span> <span class="n">uid_max</span>

<span class="c1"># Get the users from /etc/passwd</span>
<span class="k">def</span> <span class="nf">getusers</span><span class="p">(</span><span class="n">no_system</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="n">uid_min</span><span class="p">,</span> <span class="n">uid_max</span> <span class="o">=</span> <span class="n">read_login_defs</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">uid_min</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">uid_min</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="k">if</span> <span class="n">uid_max</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">uid_max</span> <span class="o">=</span> <span class="mi">60000</span>

    <span class="n">users</span> <span class="o">=</span> <span class="n">pwd</span><span class="o">.</span><span class="n">getpwall</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">users</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">no_system</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">pw_uid</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">uid_min</span> <span class="ow">and</span> <span class="n">user</span><span class="o">.</span><span class="n">pw_uid</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">uid_max</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}:{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">pw_name</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">pw_shell</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}:{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">pw_name</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">pw_shell</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;User/Password Utility&#39;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--no-system&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s1">&#39;no_system&#39;</span><span class="p">,</span>
                        <span class="n">default</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify to omit system users&#39;</span><span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="n">getusers</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">no_system</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>При выполнении программы с опцией --help вы увидете справочное сообшение о работе программы и
используемые опции.</p>
<div class="highlight"><pre><span></span>$ ./getusers.py --help
usage: getusers.py <span class="o">[</span>-h<span class="o">]</span> <span class="o">[</span>--no-system<span class="o">]</span>

User/Password Utility

optional arguments:
    -h, --help   show this <span class="nb">help</span> message and <span class="nb">exit</span>
    --no-system  Specify to omit system users
</pre></div>


<p>Пример вызова программы с аргументом <code>--no-system</code> выглядет следующим образом.</p>
<div class="highlight"><pre><span></span>$ ./getusers.py --no-system
gene:/bin/bash
</pre></div>


<p>Когда вы передаете недопустимый параметр программа выводит предупреждение:</p>
<div class="highlight"><pre><span></span>$ ./getusers.py --param
usage: getusers.py <span class="o">[</span>-h<span class="o">]</span> <span class="o">[</span>--no-system<span class="o">]</span>
getusers.py: error: unrecognized arguments: --param
</pre></div>


<p>Попробуем вкратце понять, как работает <code>argparse</code> в программе. 
Инструкция: <em>parser = argparse.ArgumentParser (description = 'User / Password Utility&gt;)</em> 
создает новый объект ArgumentParser с необязательным параметром описывающим что делает данная программа.
Затем добавляем аргументы, которые мы хотим, 
чтобы программа распознавала с помощью метода <em>add_argument()</em> 
в следующем выражении: <em>parser.add_argument 
('--no-system', action = 'store_true', dest = 'no_system', default = False, help = 'Specify to omit system users)</em>.
Первый параметр этого метода - это опция, которую пользователь программы 
будет подставлять в качестве аргумента при вызове программы, 
следующий параметр <em>action = store_true</em> указывает, что это логическая опция. 
То есть присутствие или отсутствие опции влияет на поведение программы. 
Параметр dest указывает переменную, значение которой будет доступно программе. 
Если эта опция не указана пользователем, значением по умолчанию является <em>False</em>, 
которое указывается параметром <em>default = False</em>, а последним параметром является справочное сообщение.
Наконец, аргументы анализируются с использованием метода parse_args():
args = parser.parse_args(). Как только разбор выполнен, значения параметров пользователя,
могут быть получены с помощью args.option_dest, где option_dest - это переменная dest,
которую вы указали при настройке аргументов. 
Это утверждение: getusers(args.no_system) вызывает функцию getusers () с значением параметра для no_system, 
предоставленным пользователем. Следующая программа показывает, как вы можете указать параметры, 
которые позволяют пользователю указывать небулевые предпочтения для вашей программы. </p>
<p>Эта программа является переписью листинга 6, с дополнительной опцией для указания сетевого устройства, 
которое может вас заинтересовать.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">argparse</span>

<span class="k">def</span> <span class="nf">netdevs</span><span class="p">(</span><span class="n">iface</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="sd">&#39;&#39;&#39; RX and TX bytes for each of the network devices &#39;&#39;&#39;</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/proc/net/dev&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">net_dump</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

    <span class="n">device_data</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,[</span><span class="s1">&#39;rx&#39;</span><span class="p">,</span><span class="s1">&#39;tx&#39;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">net_dump</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iface</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;lo&#39;</span><span class="p">:</span>
                <span class="n">device_data</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="n">data</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">1024.0</span><span class="o">*</span><span class="mf">1024.0</span><span class="p">),</span>
                                                    <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">8</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">1024.0</span><span class="o">*</span><span class="mf">1024.0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="n">iface</span><span class="p">:</span>
                <span class="n">device_data</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="n">data</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">1024.0</span><span class="o">*</span><span class="mf">1024.0</span><span class="p">),</span>
                                                    <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">8</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">1024.0</span><span class="o">*</span><span class="mf">1024.0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">device_data</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;Network Interface Usage Monitor&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-i&#39;</span><span class="p">,</span><span class="s1">&#39;--interface&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;iface&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Network interface&#39;</span><span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">netdevs</span> <span class="o">=</span> <span class="n">netdevs</span><span class="p">(</span><span class="n">iface</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">iface</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dev</span> <span class="ow">in</span> <span class="n">netdevs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}: {1} MiB {2} MiB&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">netdevs</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span><span class="o">.</span><span class="n">rx</span><span class="p">,</span> <span class="n">netdevs</span><span class="p">[</span><span class="n">dev</span><span class="p">]</span><span class="o">.</span><span class="n">tx</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Когда вы выполняете программу без каких-либо аргументов, 
она ведет себя точно так же, как и предыдущая версия. 
Однако вы также можете указать сетевое устройство, 
которое вас может заинтересовать. Например:</p>
<div class="highlight"><pre><span></span>$ ./net_devs_2.py

em1: <span class="m">0</span>.0 MiB <span class="m">0</span>.0 MiB
wlan0: <span class="m">146</span>.099492073 MiB <span class="m">12</span>.9737148285 MiB
virbr1: <span class="m">0</span>.0 MiB <span class="m">0</span>.0 MiB
virbr1-nic: <span class="m">0</span>.0 MiB <span class="m">0</span>.0 MiB

$ ./net_devs_2.py  --help
usage: net_devs_2.py <span class="o">[</span>-h<span class="o">]</span> <span class="o">[</span>-i IFACE<span class="o">]</span>

Network Interface Usage Monitor

optional arguments:
    -h, --help            show this <span class="nb">help</span> message and <span class="nb">exit</span>
    -i IFACE, --interface IFACE
                    Network interface

$ ./net_devs_2.py  -i wlan0
wlan0: <span class="m">146</span>.100307465 MiB <span class="m">12</span>.9777050018 MiB
</pre></div>


<p>С помощью этой статьи вы, возможно, смогли написать один или несколько полезных скриптов для себя, 
которые вы хотите использовать каждый день, как и любую другую команду Linux.
Самый простой способ сделать этот скрипт выполнимым и настроить псевдоним(alias) 
оболочки для этого скрипта. 
Вы также можете удалить расширение .py 
и поместить этот файл в стандартное местоположение исполняемых программ, 
например /usr /local /sbin.</p>
<h4>Другие полезные библиотечные модули стандартной библиотеки.</h4>
<p>Помимо стандартных библиотечных модулей, 
которые мы уже рассмотрели в этой статье, существует ряд других стандартных модулей, 
которые могут быть полезны: subprocess, ConfigParser, readline and curses. </p>
<h4>Что дальше?</h4>
<p>На этом этапе, в зависимости от вашего собственного опыта работы с Python и изучения 
внутренних компонентов Linux, вы можете следовать одному из следующих путей. Если вы пишете 
много сценариев командной оболочки или командных конвейеров 
для изучения различных внутренних элементов
Linux, взгляните на Python. Если вам нужен более простой способ написать собственные 
скрипты для выполнения различных задач, взгляните на Python. Наконец, если вы использовали
Python для программирования других видов Linux, получайте удовольствие от использования 
Python для изучения внутренних компонентов Linux.</p>
<p><a href="http://echorand.me/linux-system-mining-with-python.html">Оригинал стастьи</a></p>
  </div>
  <div class="article_meta">
    <p>Posted on: Sun 04 February 2018</p>
    <p>Category: <a href="https://neandreyblog.herokuapp.com/category/python.html">Python</a>
    </p>
  </div>


</article>


    <div id="ending_message">
      <p>&copy; ne_andrey. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. </p>
    </div>
  </main>
</body>
</html>